<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <meta http-equiv="Content-type" content="text/html; charset=utf-8" />
  <title>mktree</title>
  <meta name="viewport" content="width=device-width">
  <style>
  body {
    margin: 0;
    background-color: #555;
    position: relative;
    font-family: sans-serif;
  }
  svg {
    display: block;
    margin: 0;
    background-color: #fff;
  }
  #info_box {
    max-width: 50%;
    max-height: 50%;
    overflow: scroll;
    position: absolute;
    bottom: 14px;
    right: 14px;
    border: 1px solid #999;
    padding: 10px;
  }
  #info_box table th {
    text-align: right;
  }
  text.nodelabel {
    user-select: none;
  }
  </style>
</head>
<body>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/d3/5.7.0/d3.min.js"> </script>
<script type="text/javascript">

class MkTreeNode {
  constructor(props) {
    this.state = {
      id: props.id,
      displayName: props.displayName || null,
      parent: props.parent || null,
      data: props.data || null,
      children: []
    }
    this.toString = function() {
      return props.id;
    }
  }

  addChild(node) {
    //TODO allow reordering
    this.state.children.push(node);
    node.setParent(this);
  }

  setParent(node) {
    this.state.parent = node;
  }

  getNodeCount(includeSelf = true) {
    return this.getDescendents().length + (includeSelf ? 1 : 0);
  }

  getMaxDepth() {
    if (this.state.children.length == 0) {
      return 0;
    } else {
      return 1 + this.state.children.map(n => n.getMaxDepth()).reduce(( max, cur ) => Math.max( max, cur ), 0);
    }
  }

  getRootDistance(root = this.getRoot()) {
    return this ===root ? 0 : 1 + this.getParent().getRootDistance(root);
  }

  getLevelNodes(root = this.getRoot()) {
    return root.getDescendents(this.getRootDistance());
  }

  getLevelIndex(root = this.getRoot()) {
    return this.getLevelNodes(root).indexOf(this);
  }

  getChildren() {
    return this.state.children;
  }

  getDescendents(level = null) { //TODO change name; allow boolean includeSelf flag
    let collector = [];
    this.dft((node) => {
      if (level === null || node.getRootDistance() == level) {
        collector.push(node);
      }
    });
    return collector;
  }

  getParent(root = this.getRoot()) {
    return this.isRoot(root) ? this : this.state.parent;
  }

  isRoot(root = this.getRoot()) {
    return this === root;
  }


  getRoot() {
    return this.state.parent === null ? this : this.state.parent.getRoot();
  }

  getAncestors() {
    if (this.isRoot()) {
      return [];
    } else {
      let a = this.getParent().getAncestors();
      a.unshift(this.getParent());
      return a;
    }
  }

  dft(func, args = {}, ref) {
    args = func.call(ref, this, args);
    this.getChildren().forEach(c => {
      c.dft(func, args, ref);
    });
  }
}

class MkForest {
  constructor() {
    this.state = {
      nodes: {}
    }
  }

  addNode(node) {
    this.state.nodes[node.id] = node;
  }

  getRoots() {
    return Object.values(this.state.nodes).filter(n=>n.isRoot());
  }

  getNodes() {
    return this.state.nodes;
  }

  getMaxDepth() {
    return Object.values(this.state.nodes).filter(n=>n.isRoot()).map(n=>n.getMaxDepth()).reduce(( max, cur ) => Math.max( max, cur ), 0);
  }

  dft(func, args = {}, node = null) {
    if (node == null) {
      this.getRoots().forEach(n => {
        n.dft(func, args, n);
      });
    }
  }
}

class MkTreeView {

  constructor(props) {
    this.state = {
      forest: props.forest,
      root: props.root,
      colorFunction: props.colorFunction || function(d) {
        return '#999';
      },
      label: props.label || function(d) {
        return d.node.state.id;
      },
      focusNode: props.focusNode || null
    }

    this.svg = d3.select("body").append("svg")
      .attr("id", 'graph_svg')
    this.container = this.svg.append('g');

    this.infoBox = d3.select("body").append("div")
      .attr("id", 'info_box').append('table');
  }

  setState(newState) {
    for (let key in newState) {
      this.state[key] = newState[key];
    }
    this.draw();
  }

  draw() {

    var d = this.getDimensions();

    this.svg
      .attr("width", d.width)
      .attr("height", d.height)
      .attr("tabindex", 1);

    this.drawKey();
    this.drawLevels();
    this.drawBreadCrumb();
    this.drawSectors();
    this.drawEdgesAndNodes();
    this.drawInfoBox();
  }

  drawKey() {

  }

  drawLevels() {

  }

  drawBreadCrumb() {

  }

  drawSectors() {

  }

  position(node, dimensions, margin, level, levelNodes, maxDepth) {
    let index = levelNodes.indexOf(node);
    let levelCount = levelNodes.length;
    let w = dimensions.width - margin.l - margin.r;
    let h = dimensions.height - margin.t - margin.b;
    let frac = (1 - 3/(level + 3));
    let maxFrac = (1 - 3/(maxDepth + 3));

    //linear
    let m = h/(w * 1.0);
    let b = h * frac/maxFrac;
    let xmax = w * frac/maxFrac;
    let x = xmax * (1.0 * index + 0.5) / (levelCount);
    let radius = 20 / (level + 1);
    let length = xmax / Math.cos(Math.atan(m));
    return {
      node: node,
      label: radius > 12 || ((length / (radius * levelCount)) > 3 && radius > 3),
      r: radius,
      x: margin.l + x + radius,
      y: margin.t - m * x + b + radius
    }
  }

  drawEdgesAndNodes() {
    const MIN_LABEL_SIZE = 6.4;
    const LABEL_SIZE_FACTOR = 2;
    const LABEL_SIZE_DEFAULT = 10;
    let edges = [];
    let nodes = {};
    let dimensions = this.getDimensions();
    let depthCache = {};
    let root = this.state.root;
    let ancestors = root.getAncestors()
    let maxDepth = root.getMaxDepth() + root.getRootDistance();


    let margins = {
      l: 24,
      r: 24,
      t: ancestors.length == 0 ? 24 : 52,
      b: 24
    };

    console.log('start dft');
    root.dft(function(node){
      let level = node.getRootDistance(root);
      if (!(level in depthCache)) {
        depthCache[level] = node.getLevelNodes(root);
      }
      nodes[node.state.id] = this.position(node, dimensions, margins, level, depthCache[level], maxDepth);
      if (!node.isRoot(root) && node.getParent(root).state.id in nodes) {
        edges.push([nodes[node.getParent(root).state.id], nodes[node.state.id]]);
      }
    }, {}, this);
    console.log('end dft');

    let last = nodes[root.state.id];

    nodes = Object.values(nodes);
    let ancestorRadius = 20;
    ancestors.forEach((node, i) => {
      let n = {
        node: node,
        label: true,
        r: ancestorRadius,
        x: i*2.5*ancestorRadius + margins.l + ancestorRadius,
        y: margins.b // use bottom margin, since these are the nodes along the top
      }
      nodes.push(n)
      edges.push([n, last])
      last = n;
    })

    //EDGES
    var style = {
        line: 'edge'
      };
    var line = d3.line()
      .x(d=>d.x)
      .y(d=>d.y);

    let view = this;
    let t = this.svg.transition().duration(750);
    //Edges
    var edge = this.container.selectAll("path." + style.line)
      .data(edges, d => {
        return `${d[0].node.state.id},${d[1].node.state.id}`;
      });

    edge.exit().remove();

    edge.enter().append("path")
      .attr("class", style.line)
      .style('stroke', d=>{
        return view.state.colorFunction(d[1]);
      })
      .style('stroke-width','1.5px')
      .style('opacity',0)
      .transition(t)
          .delay(500)
        .style('opacity',1)
          .selection()
    .merge(edge)
      .transition(t)
        .attr("d", function(a) {
          return line(a);
        });


    //NODES
    var circle = this.container.selectAll("circle")
      .data(nodes.filter(node => {
        return true;
      }), d => d.node.state.id);

    circle.exit().remove();
    circle.enter().append("circle")
      .on('click', function(d) {
        view.state.focusNode = d.node;
        view.drawInfoBox();
      })
      .on('dblclick', function(d) {
        view.state.root = d.node;
        view.draw();
      })
      .attr("cx", function(d) {
        return d.x;
      })
      .attr("cy", function(d) {
        return d.y;
      })
      .attr("r", function(d){
        return d.r;
      })
      .style('opacity',0)
      .transition(t)
          .delay(500)
        .style('opacity',1)
          .selection()
    .merge(circle)
      .style('fill', view.state.colorFunction)
      .transition(t)
        .attr("cx", function(d) {
          return d.x;
        })
        .attr("cy", function(d) {
          return d.y;
        })
        .attr("r", function(d){
          return d.r;
        })
        // .style('stroke','#444')
        // .style('stroke-width','0.5px');
    //LABELS
    var nodelabels = this.container.selectAll("text")
      .data(nodes.filter(d => {
        return d.label;
      }), d => d.node.state.id);

    nodelabels.exit().remove();

    nodelabels.enter().append("text")
      .attr("class", 'nodelabel')
      .text(view.state.label)
      .attr("text-anchor", function(d) {
        return d.r > 12 ? "middle" : "start";
      })
      .attr("alignment-baseline", function(d) {
        return d.r > 12 ? "middle" : "bottom";
      })
      .attr("x", function(d){
        if (d.r > 12) {
          return d.x;
        }
        return d.x + d.r;
      })
      .attr("y", function(d){
        if (d.r > 12) {
          return d.y;
        }
        return d.y - d.r;
      })
      .style('opacity',0)
      .transition(t)
          .delay(500)
        .style('opacity',1)
          .selection()
    .merge(nodelabels)
      .style('font-size', function(d){
        if (!d.r || d.r * LABEL_SIZE_FACTOR > LABEL_SIZE_DEFAULT) {
          return LABEL_SIZE_DEFAULT + 'px'
        }
        return d.r*LABEL_SIZE_FACTOR + 'px';
      })
      .attr("text-anchor", function(d) {
        return d.r > 12 ? "middle" : "start";
      })
      .attr("alignment-baseline", function(d) {
        return d.r > 12 ? "middle" : "bottom";
      })
      .transition(t)
        .attr("x", function(d){
          if (d.r > 12) {
            return d.x;
          }
          return d.x + d.r;
        })
        .attr("y", function(d){
          if (d.r > 12) {
            return d.y;
          }
          return d.y - d.r;
        })

    nodelabels.raise();
  }

  drawInfoBox() {
    if (this.state.focusNode) {
      let graphInfo = {
        nodeCount: 0,
        levelCount: 0,
      }

      let info = this.state.focusNode.state;
      var entries = this.infoBox.selectAll("tr").data(Object.keys(info));
      //console.log(data);

      entries.exit().remove();

      let rows = entries.enter().append("tr")
        .attr("class", 'datum')
      .merge(entries)
        .html(d=>`<th>${d}</th><td>${info[d]}</td>`)
    } else {
      this.infoBox.html('');
    }
  }

  getDimensions() {
    return {
      width: window.innerWidth,
      height: window.innerHeight -
        (document.getElementById('graph_svg').getBoundingClientRect().top -
          document.body.getBoundingClientRect().top)
    }
  }
}

let f = new MkForest();
let k = 0;
let r = new MkTreeNode({ id: k });
f.addNode(r);
let total = 1;
for (let i = 0; i < 15; i++) {
  r.getDescendents(i).forEach(n=>{
    let kids = i < 10 ? 2 : 1;//Math.floor(Math.random() * 3) + 1
    for (let j = 0; j < kids; j++) {
      k++;
      n.addChild(new MkTreeNode({ id: k }));
    }
  });
}

let v = new MkTreeView({
  forest: f,
  root: r.getChildren()[0].getChildren()[0],
  focusNode: r,
  colorFunction: function(d) {
    let i = d.node.getRootDistance() * 50;
    return `rgb(${i},${255-i/3},${i/2})`
  }
})
console.log('start draw');
v.draw();
console.log('end draw');

debug = function(node, args) {
  console.log(args['indent'] + node.state.id);
  return {indent: args['indent'] + '.'};
}

/*
on node click, infobox
  total nodes
  max level
  nodes per level
  data key-values based on function of node
on svg click, deselect node
on node doubleclick, zoom to level
on hover, show node Tooltip
add key
functions for de-emphasize or do not display
sort children
*/
//f.dft(debug, {indent: ''});
//r.dft(debug, {indent: '**'});

</script>
</body>
</html>
