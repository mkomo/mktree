<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <meta http-equiv="Content-type" content="text/html; charset=utf-8" />
  <title>mktree</title>
  <meta name="viewport" content="width=device-width">
  <style>
  body {
    margin: 0;
    background-color: #555;
    position: relative;
    font-family: sans-serif;
  }
  svg {
    display: block;
    margin: 0;
    background-color: #fff;
  }
  #info_box {
    max-width: 50%;
    max-height: 50%;
    overflow: scroll;
    position: absolute;
    bottom: 14px;
    right: 14px;
    border: 1px solid #999;
    padding: 10px;
  }
  #info_box table th {
    text-align: right;
  }
  </style>
</head>
<body>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/d3/5.7.0/d3.min.js"> </script>
<script type="text/javascript">

class MkTreeNode {
  constructor(props) {
    this.state = {
      id: props.id,
      displayName: props.displayName || null,
      parent: props.parent || null,
      data: props.data || null,
      children: []
    }
    this.toString = function() {
      return props.id;
    }
  }

  addChild(node) {
    //TODO allow reordering
    this.state.children.push(node);
    node.setParent(this);
  }

  setParent(node) {
    this.state.parent = node;
  }

  getNodeCount(includeSelf = true) {
    return this.getDescendents().length + (includeSelf ? 1 : 0);
  }

  getMaxDepth() {
    if (this.state.children.length == 0) {
      return 0;
    } else {
      return 1 + this.state.children.map(n => n.getMaxDepth()).reduce(( max, cur ) => Math.max( max, cur ), 0);
    }
  }

  getRootDistance(root = this.getRoot()) {
    return this ===root ? 0 : 1 + this.getParent().getRootDistance(root);
  }

  getLevelNodes(root = this.getRoot()) {
    return root.getDescendents(this.getRootDistance());
  }

  getLevelIndex(root = this.getRoot()) {
    return this.getLevelNodes(root).indexOf(this);
  }

  getChildren() {
    return this.state.children;
  }

  getDescendents(level = null) { //TODO change name; allow boolean includeSelf flag
    let collector = [];
    this.dft((node) => {
      if (level === null || node.getRootDistance() == level) {
        collector.push(node);
      }
    });
    return collector;
  }

  getParent(root = this.getRoot()) {
    return this.isRoot(root) ? this : this.state.parent;
  }

  isRoot(root = this.getRoot()) {
    return this === root;
  }


  getRoot() {
    return this.state.parent === null ? this : this.state.parent.getRoot();
  }

  getAncestors() {
    if (this.isRoot()) {
      return [];
    } else {
      let a = this.getParent().getAncestors();
      a.push(this.getParent());
      return a;
    }
  }

  dft(func, args = {}, ref) {
    args = func.call(ref, this, args);
    this.getChildren().forEach(c => {
      c.dft(func, args, ref);
    });
  }
}

class MkForest {
  constructor() {
    this.state = {
      nodes: {}
    }
  }

  addNode(node) {
    this.state.nodes[node.id] = node;
  }

  getRoots() {
    return Object.values(this.state.nodes).filter(n=>n.isRoot());
  }

  getNodes() {
    return this.state.nodes;
  }

  getMaxDepth() {
    return Object.values(this.state.nodes).filter(n=>n.isRoot()).map(n=>n.getMaxDepth()).reduce(( max, cur ) => Math.max( max, cur ), 0);
  }

  dft(func, args = {}, node = null) {
    if (node == null) {
      this.getRoots().forEach(n => {
        n.dft(func, args, n);
      });
    }
  }
}

class MkTreeView {
  constructor(props) {
    this.state = {
      forest: props.forest,
      root: props.root,
      colorFunction: props.colorFunction || function(d) {
        return '#999';
      },
      focusNode: props.focusNode || null
    }

    this.svg = d3.select("body").append("svg")
      .attr("id", 'graph_svg')
    this.container = this.svg.append('g');

    this.infoBox = d3.select("body").append("div")
      .attr("id", 'info_box').append('table');
  }

  setState(newState) {
    for (let key in newState) {
      this.state[key] = newState[key];
    }
    this.draw();
  }

  draw() {

    var d = this.getDimensions();

    this.svg
      .attr("width", d.width)
      .attr("height", d.height)
      .attr("tabindex", 1);

    this.drawKey();
    this.drawLevels();
    this.drawBreadCrumb();
    this.drawSectors();
    this.drawEdgesAndNodes();
    this.drawInfoBox();
  }

  drawKey() {

  }

  drawLevels() {

  }

  drawBreadCrumb() {

  }

  drawSectors() {

  }

  position(node, dimensions, margin, level, levelNodes, maxDepth) {
    if (node.state.id == 1024) {
      console.log(node, dimensions, margin, level, levelNodes.indexOf(node), maxDepth)
    }
    let index = levelNodes.indexOf(node);
    let levelCount = levelNodes.length;
    let w = dimensions.width - 2*margin;
    let h = dimensions.height - 2*margin;
    let frac = (1 - 3/(level + 3));
    let maxFrac = (1 - 3/(maxDepth + 3));

    //linear
    let m = h/(w * 1.0);
    let b = margin + h * frac/maxFrac;
    let xmax = margin + w * frac/maxFrac;
    let x = margin/2 + xmax * (1.0 * index + 0.5) / (levelCount);
    return {
      node: node,
      r: 20 / (level + 1),
      x: x,
      y: margin - m * x + b
    }
  }

  drawEdgesAndNodes() {
    let edges = [];
    let nodes = {};
    let dimensions = this.getDimensions();
    let margin = 24;
    let depthCache = {};
    let root = this.state.root;
    let maxDepth = root.getMaxDepth() + root.getRootDistance();

    console.log('start dft');
    root.dft(function(node){
      let level = node.getRootDistance(root);
      if (!(level in depthCache)) {
        depthCache[level] = node.getLevelNodes(root);
      }
      nodes[node.state.id] = this.position(node, dimensions, margin, level, depthCache[level], maxDepth);
      if (!node.isRoot(root) && node.getParent(root).state.id in nodes) {
        edges.push([nodes[node.getParent(root).state.id], nodes[node.state.id]]);
      }
    }, {}, this);
    console.log('end dft');

    nodes = Object.values(nodes);

    var style = {
        line: 'edge'
      };
    var line = d3.line()
      .x(d=>d.x)
      .y(d=>d.y);

    let done = false;
    let t = this.svg.transition().duration(750);
    //Edges
    var edge = this.container.selectAll("path." + style.line)
      .data(edges, d => {
        if (!done) {
          console.log(d,`${d[0].node.state.id},${d[1].node.state.id}`)
          done = true;
        }
        return `${d[0].node.state.id},${d[1].node.state.id}`;
      });

    edge.exit().remove();

    edge.enter().append("path")
      .attr("class", style.line)
    .merge(edge)
      .transition(t)
        .style('stroke','#77777788')
        .style('stroke-width','1.5px')
        .attr("d", function(a) {
          return line(a);
        });

    //Nodes
    var circle = this.container.selectAll("circle")
      .data(nodes.filter(node => {
        return true;
      }), d => d.node.state.id);
    let view = this;

    circle.exit().remove();
    circle.enter().append("circle")
      .style("opacity", 1)
    .merge(circle)
      .style('fill', view.state.colorFunction)
      .on('click', function(d) {
        view.state.focusNode = d.node;
        view.drawInfoBox();
      })
      .on('dblclick', function(d) {
        view.state.root = d.node;
        view.draw();
      })
      .transition(t)
        .attr("cx", function(d) {
          return d.x;
        })
        .attr("cy", function(d) {
          return d.y;
        })
        .attr("r", function(d){
          return d.r;
        })
        .style('stroke','#444')
        .style('stroke-width','0.5px');
  }

  drawInfoBox() {
    if (this.state.focusNode) {
      let graphInfo = {
        nodeCount: 0,
        levelCount: 0,
      }

      let info = this.state.focusNode.state;
      var entries = this.infoBox.selectAll("tr").data(Object.keys(info));
      //console.log(data);

      entries.exit().remove();

      let rows = entries.enter().append("tr")
        .attr("class", 'datum')
      .merge(entries)
        .html(d=>`<th>${d}</th><td>${info[d]}</td>`)
    } else {
      this.infoBox.html('');
    }
  }

  getDimensions() {
    return {
      width: window.innerWidth,
      height: window.innerHeight -
        (document.getElementById('graph_svg').getBoundingClientRect().top -
          document.body.getBoundingClientRect().top)
    }
  }
}

let f = new MkForest();
let k = 0;
let r = new MkTreeNode({ id: k });
f.addNode(r);
let total = 1;
for (let i = 0; i < 15; i++) {
  r.getDescendents(i).forEach(n=>{
    let kids = i < 10 ? 2 : 1;//Math.floor(Math.random() * 3) + 1
    for (let j = 0; j < kids; j++) {
      k++;
      n.addChild(new MkTreeNode({ id: k }));
    }
  });
}

let v = new MkTreeView({
  forest: f,
  root: r,
  focusNode: r,
  colorFunction: function(d) {
    let i = d.node.getRootDistance() * 50;
    return `rgb(${i},${i},${i})`
  }
})
console.log('start draw');
v.draw();
console.log('end draw');

debug = function(node, args) {
  console.log(args['indent'] + node.state.id);
  return {indent: args['indent'] + '.'};
}

/*
on node click, infobox
  total nodes
  max level
  nodes per level
  data key-values based on function of node
on svg click, deselect node
on node doubleclick, zoom to level
on hover, show node Tooltip
add key
functions for de-emphasize or do not display
sort children
*/
//f.dft(debug, {indent: ''});
//r.dft(debug, {indent: '**'});

</script>
</body>
</html>
