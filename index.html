<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <meta http-equiv="Content-type" content="text/html; charset=utf-8" />
  <title>mktree</title>
  <meta name="viewport" content="width=device-width">
</head>
<body>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/d3/5.7.0/d3.min.js"> </script>
<script type="text/javascript">

class MkTreeNode {
  constructor(props) {
    this.state = {
      id: props.id,
      displayName: props.displayName || null,
      parent: props.parent || null,
      children: []
    }
    this.toString = function() {
      return props.id;
    }
  }

  addChild(node) {
    //TODO allow reordering
    this.state.children.push(node);
    node.setParent(this);
  }

  setParent(node) {
    this.state.parent = node;
  }

  getNodeCount(includeSelf = true) {
    return this.getDescendents().length + (includeSelf ? 1 : 0);
  }

  getMaxDepth() {
    if (this.state.children.length == 0) {
      return 0;
    } else {
      return 1 + this.state.children.map(n => n.getMaxDepth()).reduce(( max, cur ) => Math.max( max, cur ), 0);
    }
  }

  getRootDistance() {
    return this.isRoot() ? 0 : 1 + this.getParent().getRootDistance();
  }

  getTreeNodes() {

  }

  getLevelNodes() {

  }

  getLevelIndex() {

  }

  getSiblingNodes() {

  }

  getSiblingIndex() {

  }

  getChildren() {
    return this.state.children;
  }

  getDescendents(level = null) {
    let collector = [];
    this.dft((node) => {
      if (level === null || node.getRootDistance() == level) {
        collector.push(node);
      }
    });
    return collector;
  }

  getParent() {
    return this.isRoot() ? this : this.state.parent;
  }

  getRoot() {
    return this.isRoot() ? this : this.getParent().getRoot();
  }

  isRoot() {
    return this.state.parent === null;
  }

  getAncestors() {

  }

  dft(func, args = {}, root = null) {
    args = func.call(null, this, args);
    this.getChildren().forEach(c => {
      c.dft(func, args, root);
    });
  }
}

class MkForest {
  constructor() {
    this.state = {
      nodes: {}
    }
  }

  addNode(node) {
    this.state.nodes[node.id] = node;
  }

  getRoots() {
    return Object.values(this.state.nodes).filter(n=>n.isRoot());
  }

  getNodes() {
    return this.state.nodes;
  }

  getMaxDepth() {
    return Object.values(this.state.nodes).filter(n=>n.isRoot()).map(n=>n.getMaxDepth()).reduce(( max, cur ) => Math.max( max, cur ), 0);
  }

  dft(func, args = {}, node = null, root = null) {
    if (node == null) {
      this.getRoots().forEach(n => {
        this.dft(func, args, n, n);
      });
    } else {
      args = func.call(null, node, args);
      node.getChildren().forEach(c => {
        this.dft(func, args, c, root);
      });
    }
  }
}

class MkTreeView {
  constructor(props) {
    this.state = {
      forest: props.forest,
      root: props.root
    }
  }

  setState(newState) {
    for (let key in newState) {
      this.state[key] = newState[key];
    }
    this.draw();
  }

  draw() {
    this.svg = d3.select("body").append("svg")
      .attr("id", 'graph_svg')
    this.container = this.svg.append('g');

    var d = this.getDimensions();

    this.svg
      .attr("width", d.width)
      .attr("height", d.height)
      .attr("tabindex", 1);

    this.drawKey();
    this.drawLevels();
    this.drawBreadCrumb();
    this.drawSectors();
    this.drawEdgesAndNodes();
    this.drawFrame();
  }

  drawKey() {

  }

  drawLevels() {

  }

  drawBreadCrumb() {

  }

  drawSectors() {

  }

  edges() {
    return [[[0,0],[100,200]]];
  }

  nodes() {
    return [[0,0],[100,200]];
  }

  drawEdgesAndNodes() {
    var style = {
      line: 'edge'
    };
    var line = d3.line()
        .x(d=>d[0])
        .y(d=>d[1]);
    //Edges
    var edge = this.container.selectAll("path." + style.line)
      .data(this.edges());

    edge.exit().remove();

    edge.enter().append("path")
      .attr("class", style.line)
      .on("click", function(d) {
        d3.event.preventDefault();
        d3.event.stopPropagation();
        that.setState({
          selectedEdges: d,
          selectedNodes: that.mode() == MODE_SELECT_ADD ? that.state.selectedNodes : [],
          dragged: null
        });
        that.redraw();
      })
    .merge(edge)
      .style('stroke','#77777788')
      .style('stroke-width','1.5px')
      .attr("d", function(a) {
        return line(a);
      });

    //Nodes
    var circle = this.container.selectAll("circle")
      .data(this.nodes().filter(node => true));

    circle.exit().remove();
    circle.enter().append("circle")
      .style("opacity", 1)
    .merge(circle)
      .style('fill', 'rgba(255,0,255,1.0)')
      .attr("cx", function(d) {
        return d[0];
      })
      .attr("cy", function(d) {
        return d[1];
      })
      .attr("r", function(d){
        return 10;
      })
      .style('stroke','#444')
      .style('stroke-width','1.5px');
  }

  drawFrame() {

  }

  getDimensions() {
    return {
      width: window.innerWidth,
      height: window.innerHeight -
        (document.getElementById('graph_svg').getBoundingClientRect().top -
          document.body.getBoundingClientRect().top) - 8
    }
  }

}

let f = new MkForest();
let k = 0;
let r = new MkTreeNode({ id: k });
f.addNode(r);
for (let i = 0; i < 4; i++) {
  r.getDescendents(i).forEach(n=>{
    for (let j = 0; j < 2; j++) {
      k++;
      n.addChild(new MkTreeNode({ id: k }));
    }
  });
}

let v = new MkTreeView({
  forest: f,
  root: r
})

func = function(node, args) {
  console.log(args['indent'] + node.state.id);
  return {indent: args['indent'] + '.'};
}

f.dft(func, {indent: ''});

r.dft(func, {indent: '**'});
v.draw();

</script>
</body>
</html>
