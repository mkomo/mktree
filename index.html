<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <meta http-equiv="Content-type" content="text/html; charset=utf-8" />
  <title>mktree</title>
  <meta name="viewport" content="width=device-width">
</head>
<body>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/d3/5.7.0/d3.min.js"> </script>
<script type="text/javascript">

class MkTreeNode {
  constructor(props) {
    this.state = {
      id: props.id,
      displayName: props.displayName || null,
      parent: props.parent || null,
      children: []
    }
    this.toString = function() {
      return props.id;
    }
  }

  addChild(node) {
    //TODO allow reordering
    this.state.children.push(node);
    node.setParent(this);
  }

  setParent(node) {
    this.state.parent = node;
  }

  getNodeCount(includeSelf = true) {
    return this.getDescendents().length + (includeSelf ? 1 : 0);
  }

  getMaxDepth() {
    if (this.state.children.length == 0) {
      return 0;
    } else {
      return 1 + this.state.children.map(n => n.getMaxDepth()).reduce(( max, cur ) => Math.max( max, cur ), 0);
    }
  }

  getRootDistance(root = this.getRoot()) {
    return this ===root ? 0 : 1 + this.getParent().getRootDistance(root);
  }

  getLevelNodes(root = this.getRoot()) {
    return root.getDescendents(this.getRootDistance());
  }

  getLevelIndex(root = this.getRoot()) {
    return this.getLevelNodes(root).indexOf(this);
  }

  getChildren() {
    return this.state.children;
  }

  getDescendents(level = null) { //TODO change name; allow boolean includeSelf flag
    let collector = [];
    this.dft((node) => {
      if (level === null || node.getRootDistance() == level) {
        collector.push(node);
      }
    });
    return collector;
  }

  getParent() {
    return this.isRoot() ? this : this.state.parent;
  }

  getRoot() {
    return this.isRoot() ? this : this.getParent().getRoot();
  }

  isRoot() {
    return this.state.parent === null;
  }

  getAncestors() {
    if (this.isRoot()) {
      return [];
    } else {
      let a = this.getParent().getAncestors();
      a.push(this.getParent());
      return a;
    }
  }

  dft(func, args = {}, ref) {
    args = func.call(ref, this, args);
    this.getChildren().forEach(c => {
      c.dft(func, args, ref);
    });
  }
}

class MkForest {
  constructor() {
    this.state = {
      nodes: {}
    }
  }

  addNode(node) {
    this.state.nodes[node.id] = node;
  }

  getRoots() {
    return Object.values(this.state.nodes).filter(n=>n.isRoot());
  }

  getNodes() {
    return this.state.nodes;
  }

  getMaxDepth() {
    return Object.values(this.state.nodes).filter(n=>n.isRoot()).map(n=>n.getMaxDepth()).reduce(( max, cur ) => Math.max( max, cur ), 0);
  }

  dft(func, args = {}, node = null) {
    if (node == null) {
      this.getRoots().forEach(n => {
        n.dft(func, args, n);
      });
    }
  }
}

class MkTreeView {
  constructor(props) {
    this.state = {
      forest: props.forest,
      root: props.root
    }
  }

  setState(newState) {
    for (let key in newState) {
      this.state[key] = newState[key];
    }
    this.draw();
  }

  draw() {
    this.svg = d3.select("body").append("svg")
      .attr("id", 'graph_svg')
    this.container = this.svg.append('g');

    var d = this.getDimensions();

    this.svg
      .attr("width", d.width)
      .attr("height", d.height)
      .attr("tabindex", 1);

    this.drawKey();
    this.drawLevels();
    this.drawBreadCrumb();
    this.drawSectors();
    this.drawEdgesAndNodes();
    this.drawFrame();
  }

  drawKey() {

  }

  drawLevels() {

  }

  drawBreadCrumb() {

  }

  drawSectors() {

  }

  position(node, dimensions, margin, level, levelNodes) {
    let index = levelNodes.indexOf(node);
    let levelCount = levelNodes.length;
    let w = dimensions.width - 2*margin;
    let h = dimensions.height - 2*margin;
    let m = h/(w * 1.0);
    let frac = (1 - 3/(level + 3));
    let b = margin + h * frac;
    //TODO get xmax at given m and b;
    let xmax = margin + w * frac;
    let x = margin + xmax * (1.0 * index + 0.5) / (levelCount);
    return {
      node: node,
      x: x,
      y: margin - m * x + b,
      r: 20 / (level + 1)
    }
  }

  drawEdgesAndNodes() {
    let edges = [];
    let nodes = {};
    let dimensions = this.getDimensions();
    let margin = 24;
    let depthCache = {};

    console.log('start dft');
    this.state.root.dft(function(node){
      let level = node.getRootDistance();
      if (!(level in depthCache)) {
        depthCache[level] = node.getLevelNodes();
      }
      nodes[node.state.id] = this.position(node, dimensions, margin, level, depthCache[level]);
      if (!node.isRoot() && node.getParent().state.id in nodes) {
        edges.push([nodes[node.getParent().state.id], nodes[node.state.id]]);
      }
    }, {}, this);
    console.log('end dft');

    nodes = Object.values(nodes);

    var style = {
      line: 'edge'
    };
    var line = d3.line()
        .x(d=>{
          return d.x;
        })
        .y(d=>d.y);

    //Edges
    var edge = this.container.selectAll("path." + style.line)
      .data(edges);

    edge.exit().remove();

    edge.enter().append("path")
      .attr("class", style.line)
      .on("click", function(d) {
        d3.event.preventDefault();
        d3.event.stopPropagation();
        that.setState({
          selectedEdges: d,
          selectedNodes: that.mode() == MODE_SELECT_ADD ? that.state.selectedNodes : [],
          dragged: null
        });
        that.redraw();
      })
    .merge(edge)
      .style('stroke','#77777788')
      .style('stroke-width','1.5px')
      .attr("d", function(a) {
        return line(a);
      });

    //Nodes
    var circle = this.container.selectAll("circle")
      .data(nodes.filter(node => true));

    circle.exit().remove();
    circle.enter().append("circle")
      .style("opacity", 1)
    .merge(circle)
      .style('fill', 'rgba(255,0,255,1.0)')
      .attr("cx", function(d) {
        return d.x;
      })
      .attr("cy", function(d) {
        return d.y;
      })
      .attr("r", function(d){
        return d.r;
      })
      .style('stroke','#444')
      .style('stroke-width','1.5px');
  }

  drawFrame() {

  }

  getDimensions() {
    return {
      width: window.innerWidth,
      height: window.innerHeight -
        (document.getElementById('graph_svg').getBoundingClientRect().top -
          document.body.getBoundingClientRect().top) - 8
    }
  }
}

let f = new MkForest();
let k = 0;
let r = new MkTreeNode({ id: k });
f.addNode(r);
let total = 1;
for (let i = 0; i < 15; i++) {
  r.getDescendents(i).forEach(n=>{
    let kids = i < 10 ? 2 : 1;//Math.floor(Math.random() * 3) + 1
    for (let j = 0; j < kids; j++) {
      k++;
      n.addChild(new MkTreeNode({ id: k }));
    }
  });
}

let v = new MkTreeView({
  forest: f,
  root: r
})
console.log('starting draw');
v.draw();
console.log('done with draw');

debug = function(node, args) {
  console.log(args['indent'] + node.state.id);
  return {indent: args['indent'] + '.'};
}

/*
total nodes
max level
nodes per level
*/
//f.dft(debug, {indent: ''});
//r.dft(debug, {indent: '**'});

</script>
</body>
</html>
